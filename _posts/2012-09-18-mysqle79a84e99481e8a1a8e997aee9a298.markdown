---
author: admin
comments: true
date: 2012-09-18 10:39:00+00:00
layout: post
slug: mysql%e7%9a%84%e9%94%81%e8%a1%a8%e9%97%ae%e9%a2%98
title: mysql的锁表问题
wordpress_id: 68
categories:
- MYSQL
tags:
- Mysql
---





SHOW PROCESSLIST查看数据库中表的状态，是否被锁；




kill id  //杀掉被锁的表




===================================================




set autocommit=0;




select * from t1  where uid='xxxx' for update  //在有索引（例如uid）的情况下是行锁，否则是表锁




insert into t1 values(1,'xxxxx');




commit;




=====================================================




lock tables t1 write|read;




insert into t1 values(2,'xxxxx'); //只有insert




unlock tables;







2 《轻松掌握MySQL数据库锁机制的相关原理》  

  

MySQL 5.1支持对MyISAM和MEMORY表进行表级锁定，对BDB表进行页级锁定，对InnoDB 表进行行级锁定。在许多情况下，可以根据培训猜测应用程序使用哪类锁定类型最好，但一般很难说出某个给出的锁类型就比另一个好。一切取决于应用程序，应用程序的不同部分可能需要不同的锁类型。为了确定是否想要使用行级锁定的存储引擎，应看看应用程序做什么并且混合使用什么样的选择和更新语句。例如，大多数Web应用程序执行许多选择，而很少进行删除，只对关键字的值进行更新，并且只插入少量具体的表。基本MySQL
 MyISAM设置已经调节得很好。   

  

在MySQL中对于使用表级锁定的存储引擎，表锁定时不会死锁的。这通过总是在一个查询开始时立即请求所有必要的锁定并且总是以同样的顺序锁定表来管理。   

  

对WRITE，MySQL使用的表锁定方法原理如下：   

  

◆ 如果在表上没有锁，在它上面放一个写锁。   

◆否则，把锁定请求放在写锁定队列中。   

  

对READ，MySQL使用的锁定方法原理如下：   

  

◆如果在表上没有写锁定，把一个读锁定放在它上面。   

◆否则，把锁请求放在读锁定队列中。   

  

当一个锁定被释放时，锁定可被写锁定队列中的线程得到，然后是读锁定队列中的线程。   

  

这意味着，如果你在一个表上有许多更新，SELECT语句将等待直到没有更多的更新。   

  

如果INSERT 语句不冲突，可以自由为MyISAM 表混合并行的INSERT 和SELECT 语句而不需要锁定。   

  

InnoDB 使用行锁定，BDB 使用页锁定。对于这两种存储引擎，都可能存在死锁。这是因为，在SQL语句处理期间，InnoDB 自动获得行锁定，BDB 获得页锁定，而不是在事务启动时获得。   

  

行级锁定的优点：   

  

· 当在许多线程中访问不同的行时只存在少量锁定冲突。   

· 回滚时只有少量的更改。   

· 可以长时间锁定单一的行。   

  

行级锁定的缺点：   

  

· 比页级或表级锁定占用更多的内存。   

· 当在表的大部分中使用时，比页级或表级锁定速度慢，因为你必须获取更多的锁。   

· 如果你在大部分数据上经常进行 GROUP BY 操作或者必须经常扫描整个表，比其它锁定明显慢很多。   

· 用高级别锁定，通过支持不同的类型锁定，你也可以很容易地调节应用程序，因为其锁成本小于行级锁定。    

  

在以下情况下，表锁定优先于页级或行级锁定：   

  

· 表的大部分语句用于读取。   

· 对严格的关键字进行读取和更新，你可以更新或删除可以用单一的读取的关键字来提取的一行：   

• UPDATE tbl_name SET column = value WHERE unique_key_col = key_value ;   

• DELETE FROM tbl_name WHERE unique_key_col = key_value ;   

· SELECT 结合并行的INSERT 语句，并且只有很少的UPDATE或 DELETE 语句。   

· 在整个表上有许多扫描或 GROUP BY 操作，没有任何写操作。   

不同于行级或页级锁定的选项：   

· 版本(例如，为并行的插入在MySQL中使用的技术)，其中可以一个写操作，同时有许多读取操作。这明数据库或表支持数据依赖的不同视图，取决于访问何时开始。其它共同的术语是“时间跟踪”、“写复制”或者“按需复制”。   

· 按需复制在许多情况下优先于页级或行级锁定。然而，在最坏的情况下，它可能比使用常规锁定使用多的内存。   

· 除了行级锁定外，你可以使用应用程序级锁定，例如在MySQL中使用GET_LOCK()和RELEASE_LOCK()。这些是建议性锁定，它们只能在运行良好的应用程序中工作。   

  

  

为达到最高锁定速度，除InnoDB 和BDB 之外，对所有存储引擎，MySQL使用表锁定(而不是页、行或者列锁定)。对于InnoDB 和BDB 表，如果你用LOCK TABLES显式锁定表，MySQL只使用表锁定；如果你不使用LOCK TABLES，因为 InnoDB 使用自动行级锁定而BDB 使用页级锁定来保证事务隔离。   

  

但是对于大表，对于大多数应用程序，表锁定比行锁定更好，但存在部分缺陷。表锁定使许多线程同时从一个表中进行读取操作，但如果一个线程想要对表进行写操作，它必须首先获得独占访问。更新期间，所有其它想要访问该表的线程必须等待直到更新完成。   

  

表更新通常情况认为比表检索更重要，因此给予它们更高的优先级。这应确保更新一个表的活动不能“饿死”，即使该表上有很繁重的SELECT 活动。   

  

表锁定在这种情况下会造成问题，例如当线程正等待，因为硬盘已满并且在线程可以处理之前必须有空闲空间。在这种情况下，所有想要访问出现问题的表的线程也被设置成等待状态，直到有更多的硬盘空间可用。   

  

表锁定在下面的情况下也存在问题：   

  

· 一个客户发出长时间运行的查询。   

· 然后，另一个客户对同一个表进行更新。该客户必须等待直到SELECT完成。   

· 另一个客户对同一个表上发出了另一个 SELECT 语句。因为UPDATE比 SELECT 优先级高，该SELECT 语句等待UPDATE完成，并且等待第1个 SELECT 完成。   

  

下面描述了一些方法来避免或减少表锁定造成的竞争：   

  

· 试图使 SELECT 语句运行得更快。可能必须创建一些摘要(summary)表做到这点。   

· 用--low-priority-updates启动mysqld。这将给所有更新(修改)一个表的语句以比SELECT语句低的优先级。在这种情况下，在先前情形的第2个SELECT语句将在UPDATE语句前执行，而不需要等候第1个 SELECT 完成。   

· 可以使用SET_UPDATES=1语句指定具体连接中的所有更新应使用低优先级。   

· 可以用LOW_PRIORITY属性给与一个特定的INSERT、UPDATE或DELETE语句较低优先级。   

· 可以用HIGH_PRIORITY属性给与一个特定的SELECT语句较高优先级。   

· 为max_write_lock_count系统变量指定一个低值来启动mysqld来强制MySQL在具体数量的插入完成后临时提高所有等待一个表的SELECT 语句的优先级。这样允许在一定数量的WRITE锁定后给出READ锁定。   

· 如果你有关于INSERT结合SELECT的问题，切换到使用新的MyISAM表，因为它们支持并发的SELECT和INSERT。   

· 如果你对同一个表混合插入和删除，INSERT DELAYED将会有很大的帮助。   

· 如果你对同一个表混合使用 SELECT 和DELETE 语句出现问题，DELETE 的LIMIT 选项可以有所帮助。   

· 对 SELECT 语句使用SQL_BUFFER_RESULT可以帮助使表锁定时间变短。   

· 可以更改mysys/thr_lock.c中的锁代码以使用单一的队列。在这种情况下，写锁定和读锁定将具有相同的优先级，对一些应用程序会有帮助。   

  

这里是一些MySQL中表锁定相关的技巧：   

  

· 如果不混合更新与需要在同一个表中检查许多行的选择，可以进行并行操作。   

· 可以使用 LOCK TABLES 来提高速度，因为在一个锁定中进行许多更新比没有锁定的更新要快得多。将表中的内容切分为几个表也可以有所帮助。   

· 如果在MySQL中表锁定时遇到速度问题，可以将表转换为 InnoDB 或BDB 表来提高性能



